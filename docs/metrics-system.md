# Sistema de M√©tricas y Productividad

El sistema de m√©tricas de Planico proporciona an√°lisis en tiempo real del uso del tiempo y patrones de productividad del usuario.

## üìä Tipos de M√©tricas

### M√©tricas B√°sicas
```typescript
interface ProductivityMetrics {
  totalBlocks: number;           // N√∫mero total de bloques
  totalMinutes: number;          // Tiempo total planificado
  averageBlockDuration: number;  // Duraci√≥n promedio por bloque
  weeklyProgress: {
    planned: number;             // Bloques planificados
    completed: number;           // Bloques completados
    efficiency: number;          // Porcentaje de eficiencia
  };
}
```

### Desglose por Categor√≠as
```typescript
categoryBreakdown: Record<string, {
  name: string;        // Nombre de la categor√≠a
  color: string;       // Color asignado
  blocks: number;      // Cantidad de bloques
  minutes: number;     // Tiempo total en minutos
  percentage: number;  // Porcentaje del tiempo total
}>;
```

## üßÆ Algoritmos de C√°lculo

### C√°lculo de M√©tricas Semanales
```typescript
export class MetricsCalculator {
  static calculateWeeklyMetrics(
    blocks: ScheduleBlock[], 
    weekDate: Date = new Date()
  ): ProductivityMetrics {
    const weekStart = startOfWeek(weekDate, { weekStartsOn: 0 });
    const weekEnd = endOfWeek(weekDate, { weekStartsOn: 0 });

    // Filtrar bloques de la semana actual
    const weekBlocks = blocks.filter(block => 
      isWithinInterval(new Date(block.startTime), { 
        start: weekStart, 
        end: weekEnd 
      })
    );

    // C√°lculos b√°sicos
    const totalBlocks = weekBlocks.length;
    const totalMinutes = weekBlocks.reduce((sum, block) => 
      sum + differenceInMinutes(
        new Date(block.endTime), 
        new Date(block.startTime)
      ), 0
    );

    const averageBlockDuration = totalBlocks > 0 
      ? totalMinutes / totalBlocks 
      : 0;

    // Desglose por categor√≠as
    const categoryBreakdown = this.calculateCategoryBreakdown(
      weekBlocks, 
      totalMinutes
    );

    // Progreso semanal
    const weeklyProgress = this.calculateWeeklyProgress(weekBlocks);

    return {
      totalBlocks,
      totalMinutes,
      averageBlockDuration,
      categoryBreakdown,
      weeklyProgress
    };
  }
}
```

### Desglose por Categor√≠as
```typescript
private static calculateCategoryBreakdown(
  blocks: ScheduleBlock[],
  totalMinutes: number
): Record<string, CategoryMetrics> {
  const categoryMap = new Map<string, {
    name: string;
    color: string;
    blocks: number;
    minutes: number;
  }>();

  // Agrupar por categor√≠a
  blocks.forEach(block => {
    const categoryId = block.categoryId;
    const duration = differenceInMinutes(
      new Date(block.endTime), 
      new Date(block.startTime)
    );
    
    if (categoryMap.has(categoryId)) {
      const existing = categoryMap.get(categoryId)!;
      existing.blocks += 1;
      existing.minutes += duration;
    } else {
      categoryMap.set(categoryId, {
        name: block.category.name,
        color: block.category.color,
        blocks: 1,
        minutes: duration,
      });
    }
  });

  // Calcular porcentajes
  const categoryBreakdown: Record<string, CategoryMetrics> = {};
  categoryMap.forEach((data, categoryId) => {
    categoryBreakdown[categoryId] = {
      ...data,
      percentage: totalMinutes > 0 
        ? (data.minutes / totalMinutes) * 100 
        : 0,
    };
  });

  return categoryBreakdown;
}
```

### Actualizaci√≥n Incremental
```typescript
static updateMetricsAfterBlockCreation(
  currentMetrics: ProductivityMetrics,
  newBlock: ScheduleBlock
): ProductivityMetrics {
  const blockDuration = differenceInMinutes(
    new Date(newBlock.endTime), 
    new Date(newBlock.startTime)
  );

  const updatedMetrics = { ...currentMetrics };
  
  // Actualizar totales
  updatedMetrics.totalBlocks += 1;
  updatedMetrics.totalMinutes += blockDuration;
  updatedMetrics.averageBlockDuration = 
    updatedMetrics.totalMinutes / updatedMetrics.totalBlocks;

  // Actualizar categor√≠a
  const categoryId = newBlock.categoryId;
  if (updatedMetrics.categoryBreakdown[categoryId]) {
    updatedMetrics.categoryBreakdown[categoryId].blocks += 1;
    updatedMetrics.categoryBreakdown[categoryId].minutes += blockDuration;
  } else {
    updatedMetrics.categoryBreakdown[categoryId] = {
      name: newBlock.category.name,
      color: newBlock.category.color,
      blocks: 1,
      minutes: blockDuration,
      percentage: 0,
    };
  }

  // Recalcular porcentajes
  Object.keys(updatedMetrics.categoryBreakdown).forEach(catId => {
    updatedMetrics.categoryBreakdown[catId].percentage = 
      (updatedMetrics.categoryBreakdown[catId].minutes / 
       updatedMetrics.totalMinutes) * 100;
  });

  return updatedMetrics;
}
```

## üìà Visualizaci√≥n de M√©tricas

### Componente Principal
```typescript
// En page.tsx
{currentWeekBlocks.length > 0 && (
  <Card className="p-6">
    <h3 className="text-lg font-semibold mb-4">
      M√©tricas de Productividad
    </h3>
    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
      <MetricCard
        value={metrics.totalBlocks}
        label="Bloques Totales"
        icon={<Calendar />}
      />
      <MetricCard
        value={`${Math.round(metrics.totalMinutes / 60)}h`}
        label="Tiempo Total"
        icon={<Clock />}
      />
      <MetricCard
        value={`${Math.round(metrics.averageBlockDuration)}m`}
        label="Duraci√≥n Promedio"
        icon={<BarChart />}
      />
      <MetricCard
        value={`${metrics.weeklyProgress.efficiency}%`}
        label="Eficiencia"
        icon={<TrendingUp />}
      />
    </div>
  </Card>
)}
```

### Gr√°fico de Categor√≠as
```typescript
function CategoryBreakdownChart({ categoryBreakdown }: Props) {
  return (
    <div className="space-y-3">
      {Object.entries(categoryBreakdown).map(([id, category]) => (
        <div key={id} className="flex items-center gap-3">
          <div
            className="w-4 h-4 rounded-full"
            style={{ backgroundColor: category.color }}
          />
          <div className="flex-1">
            <div className="flex justify-between text-sm">
              <span className="font-medium">{category.name}</span>
              <span className="text-muted-foreground">
                {Math.round(category.percentage)}%
              </span>
            </div>
            <div className="w-full bg-muted rounded-full h-2 mt-1">
              <div
                className="h-2 rounded-full transition-all duration-300"
                style={{
                  backgroundColor: category.color,
                  width: `${category.percentage}%`
                }}
              />
            </div>
          </div>
          <div className="text-sm text-muted-foreground">
            {Math.round(category.minutes / 60)}h
          </div>
        </div>
      ))}
    </div>
  );
}
```

## üéØ M√©tricas Avanzadas

### An√°lisis de Patrones Temporales
```typescript
interface TimePatternAnalysis {
  peakHours: number[];           // Horas m√°s productivas
  preferredDuration: number;     // Duraci√≥n preferida de bloques
  categoryTrends: {
    [categoryId: string]: {
      preferredTimes: number[];  // Horarios preferidos por categor√≠a
      averageDuration: number;   // Duraci√≥n promedio por categor√≠a
    };
  };
}

static analyzeTimePatterns(blocks: ScheduleBlock[]): TimePatternAnalysis {
  const hourCounts = new Array(24).fill(0);
  const durations: number[] = [];
  const categoryTimes: Record<string, number[]> = {};

  blocks.forEach(block => {
    const startHour = new Date(block.startTime).getHours();
    const duration = differenceInMinutes(
      new Date(block.endTime),
      new Date(block.startTime)
    );

    hourCounts[startHour]++;
    durations.push(duration);

    if (!categoryTimes[block.categoryId]) {
      categoryTimes[block.categoryId] = [];
    }
    categoryTimes[block.categoryId].push(startHour);
  });

  // Encontrar horas pico (top 3)
  const peakHours = hourCounts
    .map((count, hour) => ({ hour, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 3)
    .map(item => item.hour);

  // Duraci√≥n preferida (mediana)
  const sortedDurations = durations.sort((a, b) => a - b);
  const preferredDuration = sortedDurations[
    Math.floor(sortedDurations.length / 2)
  ];

  return {
    peakHours,
    preferredDuration,
    categoryTrends: this.analyzeCategoryTrends(blocks)
  };
}
```

### M√©tricas de Eficiencia
```typescript
interface EfficiencyMetrics {
  planningAccuracy: number;      // % de bloques completados a tiempo
  timeUtilization: number;       // % del tiempo disponible utilizado
  focusScore: number;           // Puntuaci√≥n de concentraci√≥n
  consistencyScore: number;     // Consistencia en horarios
}

static calculateEfficiencyMetrics(
  blocks: ScheduleBlock[],
  completedBlocks: string[] = []
): EfficiencyMetrics {
  const totalBlocks = blocks.length;
  const completedCount = completedBlocks.length;
  
  const planningAccuracy = totalBlocks > 0 
    ? (completedCount / totalBlocks) * 100 
    : 0;

  // Calcular utilizaci√≥n de tiempo (8 horas laborales = 480 minutos)
  const totalPlannedMinutes = blocks.reduce((sum, block) => 
    sum + differenceInMinutes(
      new Date(block.endTime),
      new Date(block.startTime)
    ), 0
  );
  
  const timeUtilization = (totalPlannedMinutes / 480) * 100;

  // Focus Score basado en duraci√≥n promedio de bloques
  const averageDuration = totalPlannedMinutes / totalBlocks;
  const focusScore = Math.min((averageDuration / 60) * 100, 100);

  // Consistency Score basado en regularidad de horarios
  const consistencyScore = this.calculateConsistencyScore(blocks);

  return {
    planningAccuracy,
    timeUtilization: Math.min(timeUtilization, 100),
    focusScore,
    consistencyScore
  };
}
```

## üîÑ Actualizaci√≥n en Tiempo Real

### Hook de M√©tricas
```typescript
// En page.tsx
const [metrics, setMetrics] = useState(() => 
  MetricsCalculator.calculateWeeklyMetrics(
    scheduleBlocks.blocks, 
    weekGrid.currentWeek
  )
);

// Actualizar cuando cambien los bloques
useEffect(() => {
  const updatedMetrics = MetricsCalculator.calculateWeeklyMetrics(
    scheduleBlocks.blocks, 
    weekGrid.currentWeek
  );
  setMetrics(updatedMetrics);
}, [scheduleBlocks.blocks, weekGrid.currentWeek]);
```

### Optimizaci√≥n de Performance
```typescript
// Actualizaci√≥n incremental para operaciones frecuentes
const handleBlockCreation = useCallback(async (data: BlockFormData) => {
  try {
    const newBlock = await scheduleBlocks.createBlock(data, {
      onSuccess: (block) => {
        // Actualizaci√≥n incremental m√°s eficiente
        const updatedMetrics = MetricsCalculator.updateMetricsAfterBlockCreation(
          metrics, 
          block
        );
        setMetrics(updatedMetrics);
      }
    });
  } catch (error) {
    // Manejo de errores
  }
}, [metrics, scheduleBlocks]);
```

## üìä Exportaci√≥n de M√©tricas

### Formato de Exportaci√≥n
```typescript
interface MetricsExport {
  period: {
    start: string;
    end: string;
    type: 'week' | 'month' | 'quarter';
  };
  summary: ProductivityMetrics;
  detailed: {
    dailyBreakdown: DailyMetrics[];
    categoryAnalysis: CategoryAnalysis[];
    timePatterns: TimePatternAnalysis;
    efficiency: EfficiencyMetrics;
  };
  insights: string[];
}

// Generar insights autom√°ticos
static generateInsights(metrics: ProductivityMetrics): string[] {
  const insights: string[] = [];

  // An√°lisis de tiempo total
  if (metrics.totalMinutes > 2400) { // > 40 horas
    insights.push("‚ö†Ô∏è Est√°s planificando m√°s de 40 horas semanales. Considera reducir la carga.");
  }

  // An√°lisis de duraci√≥n promedio
  if (metrics.averageBlockDuration < 30) {
    insights.push("üí° Tus bloques son muy cortos. Considera agrupar tareas similares.");
  }

  // An√°lisis de categor√≠as
  const topCategory = Object.values(metrics.categoryBreakdown)
    .sort((a, b) => b.percentage - a.percentage)[0];
  
  if (topCategory && topCategory.percentage > 60) {
    insights.push(`üìä ${topCategory.name} ocupa ${Math.round(topCategory.percentage)}% de tu tiempo. ¬øEs intencional?`);
  }

  return insights;
}
```

## üé® Componentes de Visualizaci√≥n

### MetricCard Component
```typescript
interface MetricCardProps {
  value: string | number;
  label: string;
  icon?: React.ReactNode;
  trend?: 'up' | 'down' | 'stable';
  trendValue?: number;
}

function MetricCard({ value, label, icon, trend, trendValue }: MetricCardProps) {
  return (
    <Card className="p-4">
      <div className="flex items-center justify-between">
        <div>
          <div className="text-2xl font-bold text-primary">{value}</div>
          <div className="text-sm text-muted-foreground">{label}</div>
        </div>
        {icon && (
          <div className="text-muted-foreground">{icon}</div>
        )}
      </div>
      {trend && trendValue && (
        <div className={`text-xs mt-2 flex items-center gap-1 ${
          trend === 'up' ? 'text-green-600' : 
          trend === 'down' ? 'text-red-600' : 
          'text-gray-600'
        }`}>
          <TrendIcon trend={trend} />
          {trendValue}% vs semana anterior
        </div>
      )}
    </Card>
  );
}
```

## üöÄ Futuras Mejoras

### M√©tricas Predictivas
- Predicci√≥n de carga de trabajo
- Sugerencias de optimizaci√≥n autom√°tica
- Detecci√≥n de patrones de burnout

### Integraci√≥n con Datos Externos
- Sincronizaci√≥n con calendarios externos
- Importaci√≥n de datos de productividad
- An√°lisis comparativo con benchmarks

### Gamificaci√≥n
- Sistema de puntos y logros
- Desaf√≠os semanales de productividad
- Comparaci√≥n con otros usuarios (an√≥nima)

---

**Pr√≥ximos pasos**: Ver [Sincronizaci√≥n de Calendarios](./calendar-sync.md) para integraci√≥n externa.